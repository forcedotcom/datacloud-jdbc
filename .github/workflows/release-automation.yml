name: Automated Release Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  analyze-and-prepare:
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check_release.outputs.should_release }}
      version_type: ${{ steps.version_type.outputs.version_type }}
      new_version: ${{ steps.version.outputs.new_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
      
      - uses: gradle/actions/setup-gradle@v4
      
      - name: Check if this commit should trigger a release
        id: check_release
        run: |
          # Get the commit message
          COMMIT_MESSAGE=$(git log -1 --pretty=%B)
          echo "Commit message: $COMMIT_MESSAGE"
          
          # Check for conventional commit patterns that should trigger a release
          if echo "$COMMIT_MESSAGE" | grep -E "^(feat|fix|perf|refactor|docs|style|test|chore)(\(.+\))?!?:|BREAKING CHANGE:"; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "Release triggered by conventional commit"
          else
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "No release needed - commit doesn't match release criteria"
          fi
      
      - name: Determine version bump type
        id: version_type
        run: |
          COMMIT_MESSAGE=$(git log -1 --pretty=%B)
          
          # Check for breaking changes
          if echo "$COMMIT_MESSAGE" | grep -E "^(feat|fix|perf|refactor)(\(.+\))?!:|BREAKING CHANGE:"; then
            echo "version_type=major" >> $GITHUB_OUTPUT
            echo "Major version bump due to breaking change"
          elif echo "$COMMIT_MESSAGE" | grep -E "^feat(\(.+\))?:"; then
            echo "version_type=minor" >> $GITHUB_OUTPUT
            echo "Minor version bump for new feature"
          else
            echo "version_type=patch" >> $GITHUB_OUTPUT
            echo "Patch version bump for fix/improvement"
          fi
      
      - name: Get latest released version from GitHub
        id: current_version
        run: |
          # Get all tags and find the latest semantic version
          echo "Fetching all tags..."
          git fetch --tags --quiet
          
          # Get the latest semantic version tag (excluding non-semantic tags)
          LATEST_TAG=$(git tag --list | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -1 || echo "")
          
          if [ -n "$LATEST_TAG" ]; then
            # Remove 'v' prefix if present
            CURRENT_VERSION=${LATEST_TAG#v}
            echo "Found latest release: $CURRENT_VERSION"
          else
            # No semantic version tags found, start from 0.0.0
            CURRENT_VERSION="0.0.0"
            echo "No semantic version tags found, starting from: $CURRENT_VERSION"
          fi
          
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"
      
      - name: Determine new version
        id: version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.current_version }}"
          VERSION_TYPE="${{ steps.version_type.outputs.version_type || github.event.inputs.version_type || 'patch' }}"
          
          echo "Current version: $CURRENT_VERSION"
          echo "Version bump type: $VERSION_TYPE"
          
          # Validate current version format
          if ! echo "$CURRENT_VERSION" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' >/dev/null; then
            echo "Error: Invalid version format '$CURRENT_VERSION'. Expected format: X.Y.Z"
            exit 1
          fi
          
          # Parse current version (semantic versioning)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Validate parsed components
          if ! [[ "$MAJOR" =~ ^[0-9]+$ ]] || ! [[ "$MINOR" =~ ^[0-9]+$ ]] || ! [[ "$PATCH" =~ ^[0-9]+$ ]]; then
            echo "Error: Failed to parse version components from '$CURRENT_VERSION'"
            exit 1
          fi
          
          # Calculate new version based on bump type
          case "$VERSION_TYPE" in
            major)
              NEW_VERSION="$((MAJOR + 1)).0.0"
              ;;
            minor)
              NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
              ;;
            patch)
              NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
              ;;
            *)
              echo "Error: Invalid version type '$VERSION_TYPE'. Must be 'major', 'minor', or 'patch'"
              exit 1
              ;;
          esac
          
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "should_release=true" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

  create-tag:
    needs: analyze-and-prepare
    if: needs.analyze-and-prepare.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
      
      - name: Create and push tag
        run: |
          NEW_VERSION="${{ needs.analyze-and-prepare.outputs.new_version }}"
          TAG_NAME="v$NEW_VERSION"
          
          # Check if tag already exists
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "Tag $TAG_NAME already exists, skipping tag creation"
            exit 0
          fi
          
          # Create annotated tag
          git tag -a "$TAG_NAME" -m "Release version $NEW_VERSION"
          
          # Push tag
          git push origin "$TAG_NAME"
          
          echo "Created and pushed tag: $TAG_NAME"

  create-release:
    needs: [analyze-and-prepare, create-tag]
    if: needs.analyze-and-prepare.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate release notes
        id: release_notes
        run: |
          NEW_VERSION="${{ needs.analyze-and-prepare.outputs.new_version }}"
          TAG_NAME="v$NEW_VERSION"
          
          # Get the previous tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
          
          if [ -n "$PREVIOUS_TAG" ]; then
            # Generate changelog between tags
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" "$PREVIOUS_TAG..HEAD" --grep="^feat\|^fix\|^perf\|^refactor\|^docs\|^style\|^test\|^chore" --grep="BREAKING CHANGE")
          else
            # First release - get all commits
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --grep="^feat\|^fix\|^perf\|^refactor\|^docs\|^style\|^test\|^chore" --grep="BREAKING CHANGE")
          fi
          
          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="- Maintenance release"
          fi
          
          # Create release notes
          cat > release_notes.md << EOF
          ## What's Changed
          
          $CHANGELOG
          
          EOF
          
          echo "release_notes<<EOF" >> $GITHUB_OUTPUT
          cat release_notes.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ needs.analyze-and-prepare.outputs.new_version }}
          release_name: Release v${{ needs.analyze-and-prepare.outputs.new_version }}
          body: ${{ steps.release_notes.outputs.release_notes }}
          draft: false
          prerelease: false

  comment-on-commit:
    needs: [analyze-and-prepare, create-tag, create-release]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1
      
      - name: Comment on commit
        uses: actions/github-script@v7
        with:
          script: |
            const shouldRelease = '${{ needs.analyze-and-prepare.outputs.should_release }}';
            const versionType = '${{ needs.analyze-and-prepare.outputs.version_type }}';
            const newVersion = '${{ needs.analyze-and-prepare.outputs.new_version }}';
            
            let comment = `ðŸ“¦ **Build Complete**
            
            **Commit:** \`${context.sha.substring(0, 7)}\`
            **Branch:** \`${context.ref.replace('refs/heads/', '')}\`
            **Status:** âœ… Success`;
            
            if (shouldRelease === 'true') {
              comment += `
              
              ðŸš€ **Release Created!**
              - Version bump: ${versionType}
              - New version: ${newVersion}
              - Tag created: v${newVersion}
              - GitHub release published
              - Maven Central publishing initiated
              
              **Monitor Progress:**
              - [Release Workflow](https://github.com/${{ github.repository }}/actions/workflows/release.yml)
              - [Release Page](https://github.com/${{ github.repository }}/releases/tag/v${newVersion})`;
            } else {
              comment += `
              
              ðŸ“‹ **No Release Needed**
              - Commit doesn't match release criteria
              - Only snapshot build published
              - Use conventional commits to trigger releases`;
            }
            
            comment += `
            
            ---
            *This comment was automatically generated by the build workflow.*`;
            
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: comment
            });
